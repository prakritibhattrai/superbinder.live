// formatPdfFromMarkdown.js
import { parseTable, findTables, cleanContent } from './formatMarkdownTables.js';

// Default styling configuration
const DEFAULT_STYLES = {
  colors: {
    header: '#1a1a1a',
    subheader: '#2d2d2d',
    text: '#333333',
    muted: '#808080',
    tableHeader: '#666666',
    tableBorder: '#CCCCCC',
    tableHeaderBg: '#F5F5F5'
  },
  headerStyles: {
    h1: { fontSize: 24, spacing: 6, style: "bold" },
    h2: { fontSize: 20, spacing: 5, style: "bold" },
    h3: { fontSize: 16, spacing: 4, style: "bold" }
  },
  margins: {
    left: 15,
    right: 15,
    bottom: 20
  },
  table: {
    cell: {
      padding: 5,
      lineHeight: 10
    }
  }
};

/**
 * Draw a table in the PDF document
 */
/**
 * Draw a table in the PDF document
 */
const drawTable = (pdf, table, x, y, width, styles) => {
    const { headers, alignments, rows } = table;
    const cellPadding = styles.table.cell.padding;
    const lineHeight = styles.table.cell.lineHeight;
    
    // Calculate column widths proportionally
    const colWidths = headers.map(() => width / headers.length);
    
    // Helper to calculate row height based on content
    const getRowHeight = (cells) => {
      let maxHeight = 0;
      cells.forEach((cell, i) => {
        const text = typeof cell === 'string' ? cell : cell.text || '';
        const wrappedText = pdf.splitTextToSize(text, colWidths[i] - (cellPadding * 2));
        maxHeight = Math.max(maxHeight, wrappedText.length * lineHeight);
      });
      return maxHeight + (cellPadding * 2);
    };
  
    // Draw a single row
    const drawRow = (cells, rowY, isHeader) => {
      const rowHeight = getRowHeight(cells);
      
      if (isHeader) {
        pdf.setFillColor(styles.colors.tableHeaderBg);
        pdf.rect(x, rowY, width, rowHeight, 'F');
      }
  
      cells.forEach((cell, i) => {
        const cellX = x + colWidths.slice(0, i).reduce((sum, w) => sum + w, 0);
        const text = typeof cell === 'string' ? cell : cell.text || '';
        
        pdf.setFont("helvetica", "bold");
        pdf.setTextColor(isHeader ? styles.colors.tableHeader : styles.colors.text);
        
        const textX = alignments[i] === 'center' ? cellX + (colWidths[i] / 2) :
                     alignments[i] === 'right' ? cellX + colWidths[i] - cellPadding :
                     cellX + cellPadding;
  
        const wrappedText = pdf.splitTextToSize(cleanContent(text), colWidths[i] - (cellPadding * 2));
        wrappedText.forEach((line, j) => {
          const lineY = rowY + cellPadding + (j * lineHeight);
          pdf.text(line, textX, lineY, { 
            align: alignments[i], 
            baseline: 'top' 
          });
        });
      });
  
      return rowHeight;
    };
  
    let currentY = y;
    const headerHeight = drawRow(headers, currentY, true);
    currentY += headerHeight;
  
    // Draw data rows
    rows.forEach(row => {
      const rowHeight = drawRow(row, currentY, false);
      currentY += rowHeight;
    });
  
    // Draw grid
    pdf.setDrawColor(styles.colors.tableBorder);
    
    // Vertical lines
    let gridX = x;
    colWidths.forEach(width => {
      pdf.line(gridX, y, gridX, currentY);
      gridX += width;
    });
    pdf.line(gridX, y, gridX, currentY);
  
    // Horizontal lines
    let gridY = y;
    [headerHeight, ...rows.map(row => getRowHeight(row))].forEach(height => {
      pdf.line(x, gridY, x + width, gridY);
      gridY += height;
    });
    pdf.line(x, gridY, x + width, gridY);
  
    return currentY - y;
  };

/**
 * Create styled PDF from markdown content
 */
export const createStyledPdf = (pdf, content, filename, customStyles = {}) => {
  const styles = { ...DEFAULT_STYLES, ...customStyles };
  const { colors, headerStyles, margins } = styles;
  
  // Initialize PDF
  pdf.setFont("helvetica");
  
  // Add header
  pdf.setFontSize(12);
  pdf.setTextColor(colors.muted);
  pdf.text(filename, margins.left, 10);
  pdf.text("Generated by SuperBinder.live", pdf.internal.pageSize.width - 65, 10);
  
  // Add horizontal line
  pdf.setDrawColor(200, 200, 200);
  pdf.line(margins.left, 12, pdf.internal.pageSize.width - margins.right, 12);

  // Setup content parameters
  let y = 25;
  const pageWidth = pdf.internal.pageSize.width;
  const contentWidth = pageWidth - margins.left - margins.right;
  const pageHeight = pdf.internal.pageSize.height;
  let lastLineWasHeader = false;

  // Helper to render headers
  const renderHeader = (text, level) => {
    const style = headerStyles[level];
    if (!lastLineWasHeader) y += 3;
    
    pdf.setFont("helvetica", style.style);
    pdf.setFontSize(style.fontSize);
    pdf.setTextColor(colors.header);
    const wrappedText = pdf.splitTextToSize(text, contentWidth);
    pdf.text(wrappedText, margins.left, y);
    lastLineWasHeader = true;
    return (wrappedText.length * (style.fontSize / 3)) + style.spacing;
  };

  const lines = content.split('\n');
  let i = 0;
  while (i < lines.length) {
    // Check page boundaries
    if (y + 20 > pageHeight - margins.bottom) {
      pdf.addPage();
      y = 25;
      lastLineWasHeader = false;
      
      // Add header to new page
      pdf.setFontSize(12);
      pdf.setTextColor(colors.muted);
      pdf.text(filename, margins.left, 10);
      pdf.text("Generated by SuperBinder.live", pageWidth - 65, 10);
      pdf.line(margins.left, 12, pageWidth - margins.right, 12);
    }

    const line = lines[i].trim();
    
    // Handle tables
    if (line.startsWith('|')) {
      let tableContent = '';
      while (i < lines.length && lines[i].trim().startsWith('|')) {
        tableContent += lines[i] + '\n';
        i++;
      }
      
      const table = parseTable(tableContent);
      if (table) {
        pdf.setTextColor(colors.text);
        const tableHeight = drawTable(pdf, table, margins.left, y, contentWidth, styles);
        y += tableHeight + 10;
      }
      continue;
    }

    // Handle other markdown elements
    if (line.startsWith('# ')) {
      const text = line.replace('# ', '');
      y += renderHeader(text, 'h1');
    } 
    else if (line.startsWith('## ')) {
      const text = line.replace('## ', '');
      y += renderHeader(text, 'h2');
    }
    else if (line.startsWith('### ')) {
      const text = line.replace('### ', '');
      y += renderHeader(text, 'h3');
    }
    else if (line.startsWith('```')) {
      lastLineWasHeader = false;
      pdf.setFillColor(245, 245, 245);
      pdf.rect(margins.left, y - 5, contentWidth, 2, 'F');
      pdf.setFont("courier", "normal");
      pdf.setFontSize(11);
      pdf.setTextColor(colors.text);
      y += 4;
    }
    else if (line.startsWith('- ') || line.startsWith('* ')) {
      lastLineWasHeader = false;
      pdf.setFont("helvetica", "normal");
      pdf.setFontSize(12);
      pdf.setTextColor(colors.text);
      const text = line.replace(/^[-*]\s/, 'â€¢ ');
      const wrappedText = pdf.splitTextToSize(text, contentWidth - 10);
      pdf.text(wrappedText, margins.left + 5, y);
      y += (wrappedText.length * 5) + 2;
    }
    else if (line.length > 0) {
      lastLineWasHeader = false;
      if (!lastLineWasHeader) y += 2;
      pdf.setFont("helvetica", "normal");
      pdf.setFontSize(12);
      pdf.setTextColor(colors.text);
      const wrappedText = pdf.splitTextToSize(line, contentWidth);
      pdf.text(wrappedText, margins.left, y);
      y += (wrappedText.length * 5) + 2;
    }
    else {
      y += 4;  // Empty line spacing
    }

    i++;
  }

  // Add page numbers
  const pageCount = pdf.internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    pdf.setPage(i);
    pdf.setFont("helvetica", "normal");
    pdf.setFontSize(10);
    pdf.setTextColor(colors.muted);
    pdf.text(`Page ${i} of ${pageCount}`, pageWidth / 2, pageHeight - 10, { align: "center" });
  }

  return pdf;
};

/**
 * Convert markdown to PDF
 */
export const convertToPdf = (pdf, content, options = {}) => {
  return createStyledPdf(pdf, content, "Document", options);
};

export { DEFAULT_STYLES };